/**
* Skryptonite - Scrypt library for UWP
* Copyright © 2016 Nicholas C. Bauer, Ph.D.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma once
#include "SalsaBlock.h"
#include "ScryptElement.h"
#include "ScryptBlock.h"
#include "DetectInstructionSet.h"

namespace Skryptonite
{
	namespace Native
	{
		/**
		<summary>Encapsulates the core Scrypt algorithm.</summary>
		*/
		public ref class ScryptCore sealed
		{
		public:
			/**
			<summary>Inititializes the algorithm.</summary>
			<param name="data">The data generated by PBKDF2 to process.</param>
			<param name="elementsCount">The number of independent SMix elements the data is divided into.</param>
			<param name="processingCost">The number of elements to use in the large memory block and the number of
			random jumps through the large memory block.</param>
			<exception cref="Platform::InvalidArgumentException">Thrown when <paramref name="data"/> is null or 0 length, when
			<paramref name="elementsCount"/> or <paramref name="processingCost"/> are 0, or when the byte length of <paramref name="data"/>
			is not a multiple of 128 * elementsCount, or if an overflow would occur.</exception>
			*/
			ScryptCore(Windows::Storage::Streams::IBuffer^ data, unsigned elementsCount, unsigned processingCost);

			/**
			<summary>Performs SMix on the given element of the buffer.</summary>
			<param name="elementIndex">The element index to mix.</param>
			<exception cref="Platform::InvalidArgumentException">Thrown when <paramref name="elementIndex"/> is greater than or equal to
			ElementsCount.</exception>
			*/
			void SMix(unsigned elementIndex);

			/**
			<summary>Erases the buffer.</summary>
			<remarks>Should be called after finishing Scrypt and deriving the final key.</remarks>
			*/
			void EraseBuffer();

			/**
			<summary>Gets the number of independent elements present in the buffer.</summary>
			*/
			property unsigned ElementsCount
			{
				unsigned get() { return _elementsCount; }
			}

		private:
			Windows::Storage::Streams::IBuffer^ _buffer;
			SalsaBlock* _data;

			unsigned _elementsCount;
			unsigned _elementLength;
			unsigned _salsaBlockCountPerElement;
			unsigned _processingCost;

			/**
			<summary>Extracts a pointer to the underlying data from the buffer.</summary>
			*/
			void GetBufferPointer();

			/**
			<summary>Assigns the correct functions based on instruction set.</summary>
			*/
			void SetFunctions();

			/**
			<summary>Fills the large memory block with data mixed from the initial buffer and returns the final mixed buffer.</summary>
			<param name="workingBuffer">The element in which the data is input and output.</param>
			<param name="scryptBlock">The large memory block.</param>
			<param name="shuffleBuffer">A scratch space used internally.</param>
			*/
			void FillScryptBlock(ScryptElementPtr& workingBuffer, const ScryptBlockPtr& scryptBlock, ScryptElementPtr& shuffleBuffer);

			/**
			<summary>Mixes the working buffer by jumping around the large memory block.</summary>
			<param name="workingBuffer">The element in which the data is input and output.</param>
			<param name="scryptBlock">The large memory block.</param>
			<param name="shuffleBuffer">A scratch space used internally.</param>
			*/
			void MixWithScryptBlock(ScryptElementPtr& workingBuffer, const ScryptBlockPtr& scryptBlock, ScryptElementPtr& shuffleBuffer);


#pragma region Instruction_Set_Specific_Function_Pointers
			/**
			<summary>Loads and optimally arranges the data into the working buffer.</summary>
			<param name="workingBuffer">The element in which the data is input and output.</param>
			<param name="source">The location from which to load.</param>
			*/
			void(*PrepareData)(ScryptElementPtr& workingBuffer, SalsaBlock* source);

			/**
			<summary>Copies the working buffer into a memory location and then mixes the working buffer.</summary>
			<param name="copyDestination">The location to copy the buffer to.</param>
			<param name="workingBuffer">The element in which the data is input and output.</param>
			<param name="shuffleBuffer">A scratch space used internally.</param>
			*/
			void(*CopyAndMixBlocks)(SalsaBlock* copyDestination, ScryptElementPtr& workingBuffer, ScryptElementPtr& shuffleBuffer);

			/**
			<summary>Xors the data from a memory location into the working buffer and mixes it.</summary>
			<param name="workingBuffer">The element in which the data is input and output.</param>
			<param name="xorSource">The location of the data to xor into the working buffer.</param>
			<param name="shuffleBuffer">A scratch space used internally.</param>
			*/
			void(*XorAndMixBlocks)(ScryptElementPtr& workingBuffer, SalsaBlock* xorSource, ScryptElementPtr& shuffleBuffer);

			/**
			<summary>Restores and saves the data from the working buffer.</summary>
			<param name="destination">The location in which to store.</param>
			<param name="workingBuffer">The element in which the data is input and output.</param>
			*/
			void(*RestoreData)(SalsaBlock* destination, ScryptElementPtr& workingBuffer);
#pragma endregion
		};
	}
}



